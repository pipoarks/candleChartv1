<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradingView Candlestick Chart - Live Market Data</title>
    <meta name="description"
        content="Interactive candlestick chart visualization using TradingView Lightweight Charts for real-time market data analysis">

    <!-- TradingView Lightweight Charts Library -->
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>

    <!-- Indicators Module -->
    <script src="indicators/utils.js"></script>
    <script src="indicators/rsi.js"></script>
    <script src="indicators/advanced_rsi.js"></script>
    <script src="indicators/macd.js"></script>
    <script src="indicators/volume.js"></script>
    <script src="indicators/cmf.js"></script>
    <script src="indicators/cvd.js"></script>
    <script src="indicators/frvp-settings.js"></script>
    <script src="indicators/frvp-calculator.js"></script>
    <script src="indicators/frvp-renderer.js"></script>
    <script src="indicators/frvp.js"></script>
    <script src="indicators/overlays.js"></script>
    <script src="indicators/sync.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <h1>üìà TradingView Chart</h1>
        <p class="subtitle">Interactive Candlestick Chart with Live Market Data</p>

        <div class="controls-panel">
            <div class="controls-grid">
                <div class="input-group">
                    <label for="symbol">Symbol</label>
                    <input type="text" id="symbol" value="NSE:SBIN-EQ" placeholder="e.g., NSE:SBIN-EQ">
                </div>

                <div class="input-group">
                    <label for="resolution">Resolution (Minutes)</label>
                    <select id="resolution">
                        <option value="1">1 Minute</option>
                        <option value="5" selected>5 Minutes</option>
                        <option value="15">15 Minutes</option>
                        <option value="30">30 Minutes</option>
                        <option value="60">1 Hour</option>
                        <option value="D">Daily</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="rangeFrom">From Date</label>
                    <input type="date" id="rangeFrom" value="2026-01-01">
                </div>

                <div class="input-group">
                    <label for="rangeTo">To Date</label>
                    <input type="date" id="rangeTo" value="2026-01-01">
                </div>
            </div>

            <button class="btn" id="loadBtn" onclick="renderChart()">
                Load Chart
            </button>

            <div class="error-message" id="errorMessage"></div>
        </div>

        <!-- Drawing Tools Toolbar -->
        <div class="toolbar">
            <button class="tool-btn" id="frvpToolBtn" onclick="activateFRVPTool()" title="Fixed Volume Profile Tool">
                üìä FRVP Tool
            </button>
            <div id="frvpToolStatus" class="tool-status"></div>

            <!-- FRVP Overlays Control Panel -->
            <div id="frvpControlPanel" class="frvp-control-panel"></div>
        </div>

        <div class="chart-container">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div class="loading-text">Loading chart data...</div>
            </div>
            <div id="tvchart"></div>
        </div>

        <div id="indicators-list">
            <!-- Dynamic indicators will be appended here -->
        </div>

        <div class="add-indicator-wrapper">
            <div class="input-group" style="flex-direction: row; align-items: center; gap: 1rem;">
                <label>Add Indicator:</label>
                <select id="indicatorSelect" class="small-input" style="width: 150px;">
                    <option value="" disabled selected>Select...</option>
                    <option value="RSI">Relative Strength Index (RSI)</option>
                    <option value="AdvancedRSI">Advanced RSI Indicator</option>
                    <option value="MACD">MACD</option>
                    <option value="Volume">Volume</option>
                    <option value="CMF">Chaikin Money Flow (CMF)</option>
                    <option value="CVD">Cumulative Volume Delta (CVD)</option>
                </select>
                <button class="btn" style="padding: 0.5rem 1rem; font-size: 0.9rem;"
                    onclick="handleAddIndicator()">Add</button>
            </div>
        </div>
    </div>

    <script>
        let chart = null;
        let activeIndicators = []; // Stores { id, type, instance, settings, elId }

        // FRVP Tool State
        let frvpToolState = {
            active: false,
            firstAnchor: null,
            secondAnchor: null,
            instances: [],  // Array of placed FRVP overlays
            clickHandler: null,
            editingOverlayId: null  // ID of overlay being edited
        };
        const frvpAnchors = []; // Track active anchors (Moved to top)
        let diffGeneration = 0; // Generation counter to prevent race conditions

        /**
         * Fetch candle data from the REST API
         */
        const getData = async () => {
            const symbol = document.getElementById('symbol').value;
            const resolution = document.getElementById('resolution').value;
            const rangeFrom = document.getElementById('rangeFrom').value;
            const rangeTo = document.getElementById('rangeTo').value;

            const url = `http://localhost:3000/history?symbol=${encodeURIComponent(symbol)}&resolution=${resolution}&date_format=1&range_from=${rangeFrom}&range_to=${rangeTo}&cont_flag=1`;

            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data.s !== 'ok') {
                throw new Error(data.message || 'API returned error status');
            }

            return data;
        };

        /**
         * Transform Fyers API response to TradingView format
         * Fyers returns: { s: 'ok', candles: [[t, o, h, l, c, v], ...] }
         * TradingView expects: [{ time: timestamp, open, high, low, close }, ...]
         */
        const transformData = (apiResponse, rangeFrom, rangeTo) => {
            if (!apiResponse.candles || !Array.isArray(apiResponse.candles)) {
                throw new Error('Invalid API response: missing candles array');
            }

            const candleArray = apiResponse.candles.map(candle => {
                const [timestamp, open, high, low, close, volume] = candle;

                return {
                    time: timestamp, // Unix timestamp in seconds
                    open: parseFloat(open),
                    high: parseFloat(high),
                    low: parseFloat(low),
                    close: parseFloat(close),
                    volume: parseFloat(volume || 0),
                    sma: candle[6] ? parseFloat(candle[6]) : undefined,
                    ema: candle[7] ? parseFloat(candle[7]) : undefined,
                    long: candle[8] ? true : undefined,
                    short: candle[9] ? true : undefined
                };
            });

            // Filter candles:
            // 1. Must be within 9:15 AM - 3:30 PM IST
            // 2. Must be within selected rangeFrom and rangeTo (inclusive)
            const filteredCandles = candleArray.filter(candle => {
                const date = new Date(candle.time * 1000);
                // Get IST components
                const formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'Asia/Kolkata',
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', hour12: false
                });
                const parts = formatter.formatToParts(date);
                const istParts = {};
                parts.forEach(p => istParts[p.type] = p.value);

                const hours = parseInt(istParts.hour);
                const minutes = parseInt(istParts.minute);
                const timeInMinutes = hours * 60 + minutes;

                const marketOpenTime = 9 * 60 + 15; // 9:15 AM
                const marketCloseTime = 15 * 60 + 30; // 3:30 PM

                // Check if candle is within market hours
                const isMarketHours = timeInMinutes >= marketOpenTime && timeInMinutes <= marketCloseTime;

                // Construct a date string from IST parts to compare with range inputs
                const istDateStr = `${istParts.year}-${istParts.month}-${istParts.day}`;
                const isInDateRange = istDateStr >= rangeFrom && istDateStr <= rangeTo;

                return isMarketHours && isInDateRange;
            });

            // CRITICAL FIX: Sort candles by timestamp in ascending order
            // Lightweight Charts REQUIRES data to be sorted chronologically
            filteredCandles.sort((a, b) => a.time - b.time);

            // Remove duplicate timestamps (keep first occurrence)
            const uniqueCandles = [];
            const seenTimes = new Set();

            for (const candle of filteredCandles) {
                if (!seenTimes.has(candle.time)) {
                    uniqueCandles.push(candle);
                    seenTimes.add(candle.time);
                }
            }

            console.log(`üìä Filtered Candles (9:15 AM - 3:30 PM IST, range ${rangeFrom} to ${rangeTo}): ${filteredCandles.length}`);
            console.log(`‚úÖ Unique Sorted Candles: ${uniqueCandles.length}`);
            return uniqueCandles;
        };



        /**
         * Show error message
         */
        const showError = (message) => {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = `‚ùå Error: ${message}`;
            errorEl.classList.add('active');

            setTimeout(() => {
                errorEl.classList.remove('active');
            }, 5000);
        };

        // --- FRVP State Management Functions ---
        function resetFRVPState() {
            // 1. Remove DOM Anchors from Document
            frvpAnchors.forEach(anchor => {
                if (anchor && anchor.parentNode) anchor.parentNode.removeChild(anchor);
            });
            frvpAnchors.length = 0; // Clear array

            // 2. Remove Canvas overlays
            document.querySelectorAll('.frvp-histogram-canvas').forEach(el => el.remove());

            console.log('üßπ FRVP State Cleaned');
        }

        async function restoreFRVPState(savedConfigs) {
            if (!savedConfigs || savedConfigs.length === 0) return;
            console.log('‚ôªÔ∏è Restoring FRVP Overlays:', savedConfigs.length);

            frvpToolState.instances = []; // Ensure fresh start

            for (const config of savedConfigs) {
                try {
                    // Ensure times exist in new data range or handle gracefully
                    await renderFRVPOverlay(config.startTime, config.endTime, config.id, config.config);
                } catch (e) {
                    console.warn('Failed to restore FRVP overlay:', config.id, e);
                }
            }
            updateFRVPControlPanel();
        }

        /**
         * Render the candlestick chart with robust lifecycle management
         */
        const renderChart = async () => {
            // INCREMENT GENERATION: This invalidates any pending async operations from previous runs
            const currentGen = ++diffGeneration;

            const loadingEl = document.getElementById('loading');
            const loadBtn = document.getElementById('loadBtn');
            const chartEl = document.getElementById('tvchart');
            const errorEl = document.getElementById('errorMessage');

            try {
                // 1. CLEANUP PHASE
                // Backup existing FRVP configurations (Persistence)
                const savedFRVPConfigs = frvpToolState.instances.map(i => ({
                    id: i.id,
                    startTime: i.startTime,
                    endTime: i.endTime,
                    config: i.config
                }));
                resetFRVPState(); // Clean old DOM elements and arrays

                // Stop observing resize to prevent callbacks on dead objects
                if (window.resizeObserver) {
                    window.resizeObserver.disconnect();
                }

                // Explicitly remove and nullify existing charts
                if (chart) {
                    try { chart.remove(); } catch (e) { }
                    chart = null;
                }

                // Cleanup indicator INSTANCES but keep metadata/UI
                activeIndicators.forEach(ind => {
                    if (ind.instance) {
                        try { ind.instance.chart.remove(); } catch (e) { }
                        ind.instance = null;
                    }
                });

                candleSeries = null;

                // Show loading state
                loadingEl.classList.add('active');
                loadBtn.disabled = true;
                chartEl.style.opacity = '0.3';

                // 2. DATA FETCH PHASE
                const apiData = await getData();

                // CHECK GENERATION: If user clicked load again while fetching, abort this run
                if (currentGen !== diffGeneration) {
                    console.log('üö´ Render aborted: simpler generation superseded');
                    return;
                }

                // Transform data
                const rangeFrom = document.getElementById('rangeFrom').value;
                const rangeTo = document.getElementById('rangeTo').value;
                klinedata = transformData(apiData, rangeFrom, rangeTo);

                if (klinedata.length === 0) {
                    throw new Error('No data available for the selected parameters');
                }

                // 3. CHART CREATION PHASE
                const chartProperties = {
                    layout: {
                        background: { color: '#ffffff' }, // White background
                        textColor: '#333333',
                    },
                    grid: {
                        vertLines: { color: 'rgba(148, 163, 184, 0.15)' }, // More visible grid
                        horzLines: { color: 'rgba(148, 163, 184, 0.15)' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: 'rgba(148, 163, 184, 0.3)',
                    },
                    timeScale: {
                        borderColor: 'rgba(148, 163, 184, 0.3)',
                        timeVisible: true,
                        secondsVisible: false,
                        tickMarkFormatter: (time, tickMarkType, locale) => {
                            const date = new Date(time * 1000);

                            // For day/month labels (tickMarkType 0-2)
                            if (tickMarkType <= 2) {
                                return new Intl.DateTimeFormat('en-US', {
                                    timeZone: 'Asia/Kolkata',
                                    day: '2-digit',
                                    month: 'short'
                                }).format(date);
                            }

                            // For time labels (tickMarkType 3+) - show in "DD MMM HH:mm" format
                            // This matches the crosshair tooltip format
                            return new Intl.DateTimeFormat('en-US', {
                                timeZone: 'Asia/Kolkata',
                                day: '2-digit',
                                month: 'short',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: false
                            }).format(date);
                        },
                    },
                    localization: {
                        locale: 'en-IN',
                        timeFormatter: (time) => {
                            // Crosshair tooltip formatter - matches X-axis format
                            const date = new Date(time * 1000);
                            return new Intl.DateTimeFormat('en-US', {
                                timeZone: 'Asia/Kolkata',
                                day: '2-digit',
                                month: 'short',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: false
                            }).format(date);
                        },
                    },
                    watermark: {
                        visible: true,
                        fontSize: 48,
                        horzAlign: 'center',
                        vertAlign: 'center',
                        color: 'rgba(99, 102, 241, 0.1)',
                        text: document.getElementById('symbol').value,
                    },
                };

                // Create new chart instance
                chart = LightweightCharts.createChart(chartEl, chartProperties);

                // Add candlestick series
                candleSeries = chart.addCandlestickSeries({
                    upColor: '#10b981',
                    downColor: '#ef4444',
                    borderUpColor: '#10b981',
                    borderDownColor: '#ef4444',
                    wickUpColor: '#10b981',
                    wickDownColor: '#ef4444',
                });

                candleSeries.setData(klinedata);

                // Add SMA/EMA indicators
                addSMAIndicator(chart, klinedata);
                addEMAIndicator(chart, klinedata);
                addTradeMarkers(candleSeries, klinedata);

                // Add default Volume Overlay
                addVolumeOverlay(chart, klinedata, { showSma: true, smaPeriod: 20 });

                // ========== RENDER ACTIVE INDICATORS ==========
                renderActiveIndicators();

                // ========== SYNCHRONIZE ==========
                const setupSync = () => {
                    if (currentGen !== diffGeneration) return;

                    const activeInstances = activeIndicators.map(i => i.instance).filter(Boolean);

                    if (chart && activeInstances.length > 0) {
                        try {
                            synchronizeCharts(chart, candleSeries, activeInstances);

                            // Range sync
                            const range = chart.timeScale().getVisibleLogicalRange();
                            activeInstances.forEach(ind => {
                                if (ind.chart) ind.chart.timeScale().setVisibleLogicalRange(range);
                            });
                        } catch (e) {
                            console.warn('Sync failed', e);
                        }
                    }
                };

                setTimeout(setupSync, 50);

                // Re-connect Resize Observer
                if (window.resizeObserver) {
                    window.resizeObserver.observe(chartEl);
                    // Observe any active indicator containers
                    activeIndicators.forEach(ind => {
                        const el = document.getElementById(ind.elId);
                        if (el) window.resizeObserver.observe(el);
                    });
                }

                // Setup FRVP Listeners (Anchors & Histograms)
                setupFRVPListeners();

                // Restore FRVP Overlays (Persistence)
                await restoreFRVPState(savedFRVPConfigs);

                console.log(`‚úÖ Chart loaded successfully with ${klinedata.length} candles`);

            } catch (error) {
                console.error('Chart rendering error:', error);
                showError(error.message || 'Failed to load chart data');
            } finally {
                // Hide loading state
                loadingEl.classList.remove('active');
                loadBtn.disabled = false;
                chartEl.style.opacity = '1';
            }
        };

        function setupFRVPListeners() {
            if (!chart) return;

            // 1. Anchor Sync
            chart.timeScale().subscribeVisibleTimeRangeChange(updateAllAnchors);
            chart.timeScale().subscribeVisibleLogicalRangeChange(updateAllAnchors);

            // 2. Histogram Sync
            const redrawHistograms = () => {
                frvpToolState.instances.forEach(overlay => {
                    if (overlay.canvas && overlay.profileData) {
                        drawHistogram(overlay.canvas, overlay.profileData, overlay.startTime, overlay.endTime);
                    }
                });
            };

            chart.timeScale().subscribeVisibleTimeRangeChange(redrawHistograms);
            chart.timeScale().subscribeVisibleLogicalRangeChange(redrawHistograms);

            console.log('‚úÖ FRVP Listeners Attached in setupFRVPListeners');
        }

        let candleSeries = null;

        // Static reference for data
        let klinedata = [];

        // Global Resize Observer to handle responsive layout without leaks
        window.resizeObserver = new ResizeObserver(() => {
            const chartEl = document.getElementById('tvchart');

            if (chart && chartEl) {
                try { chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight }); } catch (e) { }
            }

            // Resize active indicators
            activeIndicators.forEach(ind => {
                const el = document.getElementById(ind.elId);
                if (ind.instance && ind.instance.chart && el) {
                    try { ind.instance.chart.applyOptions({ width: el.clientWidth, height: el.clientHeight }); } catch (e) { }
                }
            });
        });


        /**
         * Add a new indicator to the list
         */
        const handleAddIndicator = () => {
            const type = document.getElementById('indicatorSelect').value;
            if (!type) return;

            const id = 'ind_' + Date.now() + Math.random().toString(36).substr(2, 5);
            const elId = 'chart_' + id;

            // Default settings based on type
            let settings = {};
            if (type === 'RSI') {
                settings = { rsiPeriod: 14, showSma: false, smaPeriod: 14, smaColor: '#f59e0b' };
            } else if (type === 'AdvancedRSI') {
                settings = {
                    rsiPeriod: 14,
                    rsiSource: 'close',
                    calculateDivergence: true,
                    maType: 'SMA',
                    maLength: 14,
                    bbMult: 2.0
                };
            } else if (type === 'MACD') {
            } else if (type === 'Volume') {
                settings = { showSma: true, smaPeriod: 20 };
            } else if (type === 'CMF') {
                settings = { length: 20, refColor: '#ef4444' };
            } else if (type === 'CVD') {
                const currentResolution = document.getElementById('resolution').value;
                settings = {
                    chartTimeframe: currentResolution,
                    anchorPeriod: '1D',
                    showUnderlyingCandles: false
                };
            } else if (type === 'FRVP') {
                settings = JSON.parse(JSON.stringify(DEFAULT_FRVP_CONFIG)); // Deep clone
            }

            // Add to state
            activeIndicators.push({ id, type, settings, elId, instance: null });

            // Create DOM
            const list = document.getElementById('indicators-list');
            const card = document.createElement('div');
            card.className = 'indicator-card';
            card.id = 'card_' + id;
            card.innerHTML = `
                <div class="indicator-header-row">
                    <div class="indicator-title-group">
                        <div class="indicator-title">üìä ${type}</div>
                    </div>
                    <div class="remove-indicator-btn" onclick="removeIndicator('${id}')" title="Remove">‚úï</div>
                </div>
                <!-- Dynamic Settings Controls would go here, simplified for now -->
                 <div class="indicator-settings">
                     ${getSettingsHTML(type, id, settings)}
                 </div>
                <div id="${elId}" class="chart-wrapper"></div>
            `;
            list.appendChild(card);

            // Observe resize
            if (window.resizeObserver) window.resizeObserver.observe(document.getElementById(elId));

            // Render if data exists
            if (klinedata.length > 0) {
                renderSingleIndicator(activeIndicators[activeIndicators.length - 1]);

                // Resync
                if (chart) {
                    const activeInstances = activeIndicators.map(i => i.instance).filter(Boolean);
                    synchronizeCharts(chart, candleSeries, activeInstances);
                    const range = chart.timeScale().getVisibleLogicalRange();
                    activeInstances.forEach(i => i.chart.timeScale().setVisibleLogicalRange(range));
                }
            }
        };

        /**
         * Generate HTML for settings based on type
         */
        const getSettingsHTML = (type, id, settings) => {
            if (type === 'RSI') {
                return `
                   <div class="settings-group">
                        <label>Length</label>
                        <input type="number" class="small-input" value="${settings.rsiPeriod}" onchange="updateIndicator('${id}', 'rsiPeriod', this.value)">
                   </div>
                   <div class="settings-group">
                        <label class="checkbox-wrap">
                            <input type="checkbox" ${settings.showSma ? 'checked' : ''} 
                                onchange="updateIndicator('${id}', 'showSma', this.checked); document.getElementById('sma-controls-${id}').style.display = this.checked ? 'flex' : 'none'"> Enable SMA
                        </label>
                   </div>
                   <div id="sma-controls-${id}" class="settings-group" style="display: ${settings.showSma ? 'flex' : 'none'}; gap: 0.75rem; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 1rem;">
                        <label>SMA Length</label>
                        <input type="number" class="small-input" value="${settings.smaPeriod || 14}" onchange="updateIndicator('${id}', 'smaPeriod', this.value)">
                        <label>Color</label>
                        <input type="color" class="color-input" value="${settings.smaColor || '#f59e0b'}" onchange="updateIndicator('${id}', 'smaColor', this.value)">
                   </div>
                `;
            } else if (type === 'AdvancedRSI') {
                return `
                   <div class="settings-group">
                        <label>RSI Length</label>
                        <input type="number" class="small-input" value="${settings.rsiPeriod}" onchange="updateIndicator('${id}', 'rsiPeriod', this.value)">
                   </div>
                   <div class="settings-group">
                        <label class="checkbox-wrap">
                            <input type="checkbox" ${settings.calculateDivergence ? 'checked' : ''} 
                                onchange="updateIndicator('${id}', 'calculateDivergence', this.checked)"> Divergence
                        </label>
                   </div>
                   <div class="settings-group">
                        <label>MA Type</label>
                        <select class="small-input" onchange="updateIndicator('${id}', 'maType', this.value)">
                            <option value="None" ${settings.maType === 'None' ? 'selected' : ''}>None</option>
                            <option value="SMA" ${settings.maType === 'SMA' ? 'selected' : ''}>SMA</option>
                            <option value="EMA" ${settings.maType === 'EMA' ? 'selected' : ''}>EMA</option>
                            <option value="SMMA" ${settings.maType === 'SMMA' ? 'selected' : ''}>SMMA (RMA)</option>
                            <option value="WMA" ${settings.maType === 'WMA' ? 'selected' : ''}>WMA</option>
                            <option value="VWMA" ${settings.maType === 'VWMA' ? 'selected' : ''}>VWMA</option>
                            <option value="BB" ${settings.maType === 'BB' ? 'selected' : ''}>SMA + Bollinger Bands</option>
                        </select>
                   </div>
                   <div class="settings-group" style="display: ${settings.maType !== 'None' ? 'flex' : 'none'}">
                        <label>MA Length</label>
                        <input type="number" class="small-input" value="${settings.maLength}" onchange="updateIndicator('${id}', 'maLength', this.value)">
                   </div>
                   <div class="settings-group" style="display: ${settings.maType === 'BB' ? 'flex' : 'none'}">
                        <label>BB Mult</label>
                        <input type="number" step="0.1" class="small-input" value="${settings.bbMult}" onchange="updateIndicator('${id}', 'bbMult', this.value)">
                   </div>
                `;
            } else if (type === 'MACD') {
                return `
                   <div class="settings-group">
                        <label>Fast</label>
                        <input type="number" class="small-input" value="${settings.fastLength}" onchange="updateIndicator('${id}', 'fastLength', this.value)">
                   </div>
                   <div class="settings-group">
                        <label>Slow</label>
                        <input type="number" class="small-input" value="${settings.slowLength}" onchange="updateIndicator('${id}', 'slowLength', this.value)">
                   </div>
                   <div class="settings-group">
                        <label>Signal</label>
                        <input type="number" class="small-input" value="${settings.signalLength}" onchange="updateIndicator('${id}', 'signalLength', this.value)">
                   </div>
                `;
            } else if (type === 'Volume') {
                return `
                   <div class="settings-group">
                        <label class="checkbox-wrap">
                            <input type="checkbox" ${settings.showSma ? 'checked' : ''} onchange="updateIndicator('${id}', 'showSma', this.checked)"> Enable SMA
                        </label>
                   </div>
                   <div class="settings-group" style="display: ${settings.showSma ? 'flex' : 'none'}">
                        <label>Length</label>
                        <input type="number" class="small-input" value="${settings.smaPeriod}" onchange="updateIndicator('${id}', 'smaPeriod', this.value)">
                   </div>
                `;
            } else if (type === 'CMF') {
                return `
                   <div class="settings-group">
                        <label>Length</label>
                        <input type="number" class="small-input" value="${settings.length}" onchange="updateIndicator('${id}', 'length', this.value)">
                        <label style="margin-left: 1rem;">Ref Color</label>
                        <input type="color" class="color-input" value="${settings.refColor || '#ef4444'}" onchange="updateIndicator('${id}', 'refColor', this.value)">
                   </div>
                `;
            } else if (type === 'CVD') {
                return `
                   <div class="settings-group">
                        <label>Anchor Period</label>
                        <select class="small-input" onchange="updateIndicator('${id}', 'anchorPeriod', this.value)">
                            <option value="1H" ${settings.anchorPeriod === '1H' ? 'selected' : ''}>1 Hour</option>
                            <option value="4H" ${settings.anchorPeriod === '4H' ? 'selected' : ''}>4 Hours</option>
                            <option value="1D" ${settings.anchorPeriod === '1D' ? 'selected' : ''}>1 Day</option>
                            <option value="1W" ${settings.anchorPeriod === '1W' ? 'selected' : ''}>1 Week</option>
                        </select>
                         <label style="margin-left: 1rem;">Timeframe: ${settings.chartTimeframe}min</label>
                   </div>
                `;
            } else if (type === 'FRVP') {
                return `
                   <div class="settings-group">
                        <label>Row Size</label>
                        <input type="number" class="small-input" value="${settings.rowSize}" onchange="updateIndicator('${id}', 'rowSize', this.value)">
                        <label style="margin-left: 1rem;">Volume</label>
                        <select class="small-input" onchange="updateIndicator('${id}', 'volume', this.value)">
                            <option value="Total" ${settings.volume === 'Total' ? 'selected' : ''}>Total</option>
                            <option value="Up/Down" ${settings.volume === 'Up/Down' ? 'selected' : ''}>Up/Down</option>
                            <option value="Delta" ${settings.volume === 'Delta' ? 'selected' : ''}>Delta</option>
                        </select>
                   </div>
                   <div class="settings-group">
                        <label>Value Area %</label>
                        <input type="number" class="small-input" value="${settings.valueAreaVolume}" min="0" max="100" onchange="updateIndicator('${id}', 'valueAreaVolume', this.value)">
                        <label style="margin-left: 1rem;">Width %</label>
                        <input type="number" class="small-input" value="${settings.volumeProfile.width}" min="0" max="100" onchange="updateIndicator('${id}', 'volumeProfile.width', this.value)">
                   </div>
                   <div class="settings-group">
                        <label>Up Volume</label>
                        <input type="color" class="color-input" value="${settings.colors.upVolume.color}" onchange="updateIndicator('${id}', 'colors.upVolume.color', this.value)">
                        <label style="margin-left: 1rem;">Down Volume</label>
                        <input type="color" class="color-input" value="${settings.colors.downVolume.color}" onchange="updateIndicator('${id}', 'colors.downVolume.color', this.value)">
                   </div>
                   <div class="settings-group">
                        <label class="checkbox-wrap">
                            <input type="checkbox" ${settings.indicators.POC.enabled ? 'checked' : ''} onchange="updateIndicator('${id}', 'indicators.POC.enabled', this.checked)"> POC
                        </label>
                        <label class="checkbox-wrap" style="margin-left: 1rem;">
                            <input type="checkbox" ${settings.indicators.VAH.enabled ? 'checked' : ''} onchange="updateIndicator('${id}', 'indicators.VAH.enabled', this.checked)"> VAH
                        </label>
                        <label class="checkbox-wrap" style="margin-left: 1rem;">
                            <input type="checkbox" ${settings.indicators.VAL.enabled ? 'checked' : ''} onchange="updateIndicator('${id}', 'indicators.VAL.enabled', this.checked)"> VAL
                        </label>
                   </div>
                `;
            }
            return '';
        };

        /**
         * Update an indicator setting
         */
        const updateIndicator = (id, key, value) => {
            const ind = activeIndicators.find(i => i.id === id);
            if (!ind) return;

            // Parse value
            // Parse value
            if (key === 'showSma' || key === 'calculateDivergence') {
                ind.settings[key] = value;
            } else if (key === 'smaColor' || key === 'maType' || key === 'refColor' || key === 'anchorPeriod' || key === 'volume') {
                ind.settings[key] = value;
            } else if (key === 'bbMult') {
                ind.settings[key] = parseFloat(value);
            } else if (key.includes('.')) {
                // Handle nested settings (e.g., 'volumeProfile.width', 'colors.upVolume.color', 'indicators.POC.enabled')
                const keys = key.split('.');
                let current = ind.settings;
                for (let i = 0; i < keys.length - 1; i++) {
                    if (!current[keys[i]]) current[keys[i]] = {};
                    current = current[keys[i]];
                }
                // Parse value based on type
                if (typeof value === 'boolean') {
                    current[keys[keys.length - 1]] = value;
                } else if (!isNaN(value) && value !== '') {
                    current[keys[keys.length - 1]] = parseFloat(value) || parseInt(value);
                } else {
                    current[keys[keys.length - 1]] = value;
                }
            } else {
                ind.settings[key] = parseInt(value);
            }

            // Re-render
            renderSingleIndicator(ind);

            // CRITICAL: Re-sync charts to prevent "Object is disposed" errors
            // This updates the closure in indicators.js with the NEW chart instances
            if (chart && candleSeries) {
                const activeInstances = activeIndicators.map(i => i.instance).filter(Boolean);
                try {
                    synchronizeCharts(chart, candleSeries, activeInstances);

                    // Also sync time range to match main chart
                    const range = chart.timeScale().getVisibleLogicalRange();
                    if (range && ind.instance && ind.instance.chart) {
                        try { ind.instance.chart.timeScale().setVisibleLogicalRange(range); } catch (e) { }
                    }
                } catch (e) { console.warn('Resync failed after update', e); }
            }
        };

        /**
         * Remove an indicator
         */
        const removeIndicator = (id) => {
            const index = activeIndicators.findIndex(i => i.id === id);
            if (index === -1) return;

            const ind = activeIndicators[index];
            if (ind.instance) {
                try { ind.instance.chart.remove(); } catch (e) { }
            }

            // Remove DOM
            const card = document.getElementById('card_' + id);
            if (card) {
                // Unobserve resize
                const wrapper = document.getElementById('chart_' + id);
                if (wrapper && window.resizeObserver) window.resizeObserver.unobserve(wrapper);
                card.remove();
            }

            // Remove from state
            activeIndicators.splice(index, 1);

            // Re-sync remaining charts to effectively unsubscribe the dead one
            if (chart && candleSeries) {
                const activeInstances = activeIndicators.map(i => i.instance).filter(Boolean);
                // We must call this to update the closure in indicators.js with the NEW list of charts
                // This prevents the sync handlers from trying to talk to the disposed chart
                try {
                    synchronizeCharts(chart, candleSeries, activeInstances);
                } catch (e) { console.warn('Re-sync failed on remove', e); }
            }
        };

        /**
         * Render all active indicators
         */
        const renderActiveIndicators = () => {
            activeIndicators.forEach(ind => renderSingleIndicator(ind));
        };

        /**
         * Render a single indicator
         */
        const renderSingleIndicator = (ind) => {
            if (!klinedata || klinedata.length === 0) return;

            const el = document.getElementById(ind.elId);
            if (!el) return;

            // Cleanup existing instance if any (for refetch/update)
            // But reuse container
            if (ind.instance) {
                try { ind.instance.chart.remove(); } catch (e) { }
            }

            // Check generation safety? No, this is synchronous mostly, but called from async renderChart

            try {
                if (ind.type === 'RSI') {
                    // Safety check for data length vs period
                    if (klinedata.length <= ind.settings.rsiPeriod) {
                        console.warn('Data too short for RSI period');
                    }
                    const rsiData = calculateRSI(klinedata, ind.settings.rsiPeriod);
                    ind.instance = createRSIChart(el, rsiData, { ...ind.settings, fullData: klinedata });
                } else if (ind.type === 'AdvancedRSI') {
                    const advRsiData = calculateAdvancedRSI(klinedata, ind.settings);
                    ind.instance = createAdvancedRSIChart(el, advRsiData, { ...ind.settings, fullData: klinedata });
                } else if (ind.type === 'MACD') {
                    if (klinedata.length <= ind.settings.slowLength) {
                        console.warn('Data too short for MACD period');
                    }
                    const macdData = calculateMACD(klinedata, ind.settings);
                    ind.instance = createMACDChart(el, macdData, { ...ind.settings, fullData: klinedata });
                } else if (ind.type === 'Volume') {
                    ind.instance = createVolumeChart(el, klinedata, { ...ind.settings, fullData: klinedata });
                } else if (ind.type === 'CMF') {
                    const cmfData = calculateCMF(klinedata, ind.settings.length);
                    ind.instance = createCMFChart(el, cmfData, { ...ind.settings, fullData: klinedata });
                } else if (ind.type === 'CVD') {
                    // Fetch 1-minute data for CVD calculation
                    const symbol = document.getElementById('symbol').value;
                    const rangeFrom = document.getElementById('rangeFrom').value;
                    const rangeTo = document.getElementById('rangeTo').value;

                    fetchOneMinuteData(symbol, rangeFrom, rangeTo)
                        .then(oneMinData => {
                            const cvdData = calculateCVD(klinedata, oneMinData, ind.settings);
                            ind.instance = createCVDChart(el, cvdData, { ...ind.settings, fullData: klinedata });

                            // Re-sync after async render
                            if (chart && candleSeries) {
                                const activeInstances = activeIndicators.map(i => i.instance).filter(Boolean);
                                try {
                                    synchronizeCharts(chart, candleSeries, activeInstances);
                                    const range = chart.timeScale().getVisibleLogicalRange();
                                    if (range && ind.instance && ind.instance.chart) {
                                        ind.instance.chart.timeScale().setVisibleLogicalRange(range);
                                    }
                                } catch (e) { console.warn('CVD sync failed', e); }
                            }
                        })
                        .catch(err => {
                            console.error('Failed to calculate CVD:', err);
                            el.innerHTML = `<div style="color: #ef4444; padding: 1rem;">‚ùå Failed to load CVD: ${err.message}</div>`;
                        });
                } else if (ind.type === 'FRVP') {
                    // Fetch data and calculate FRVP
                    const symbol = document.getElementById('symbol').value;
                    const rangeFrom = document.getElementById('rangeFrom').value;
                    const rangeTo = document.getElementById('rangeTo').value;

                    calculateFRVP(klinedata, symbol, rangeFrom, rangeTo, ind.settings)
                        .then(profileData => {
                            ind.instance = createFRVPChart(el, profileData, ind.settings);

                            // Re-sync after async render
                            if (chart && candleSeries) {
                                const activeInstances = activeIndicators.map(i => i.instance).filter(Boolean);
                                try {
                                    synchronizeCharts(chart, candleSeries, activeInstances);
                                    const range = chart.timeScale().getVisibleLogicalRange();
                                    if (range && ind.instance && ind.instance.chart) {
                                        ind.instance.chart.timeScale().setVisibleLogicalRange(range);
                                    }
                                } catch (e) { console.warn('FRVP sync failed', e); }
                            }
                        })
                        .catch(err => {
                            console.error('Failed to calculate FRVP:', err);
                            el.innerHTML = `<div style="color: #ef4444; padding: 1rem;">‚ùå Failed to load FRVP: ${err.message}</div>`;
                        });
                }
            } catch (e) {
                console.error('Failed to render indicator', ind.type, e);
            }
        };

        /**
         * FRVP Tool Functions
         */
        function activateFRVPTool() {
            frvpToolState.active = true;
            frvpToolState.firstAnchor = null;
            frvpToolState.secondAnchor = null;

            // Update button state
            document.getElementById('frvpToolBtn').classList.add('active');

            // Update status
            updateFRVPToolStatus('Click on chart to set start point...');

            // Change cursor
            document.getElementById('tvchart').style.cursor = 'crosshair';

            // Subscribe to chart clicks
            if (chart) {
                frvpToolState.clickHandler = handleFRVPChartClick;
                chart.subscribeClick(frvpToolState.clickHandler);
            }
        }

        function deactivateFRVPTool() {
            frvpToolState.active = false;
            frvpToolState.firstAnchor = null;
            frvpToolState.secondAnchor = null;

            // Update button state
            document.getElementById('frvpToolBtn').classList.remove('active');

            // Clear status
            updateFRVPToolStatus('');

            // Reset cursor
            document.getElementById('tvchart').style.cursor = 'default';

            // Unsubscribe from clicks
            if (chart && frvpToolState.clickHandler) {
                chart.unsubscribeClick(frvpToolState.clickHandler);
                frvpToolState.clickHandler = null;
            }
        }

        function updateFRVPToolStatus(message) {
            document.getElementById('frvpToolStatus').textContent = message;
        }

        function handleFRVPChartClick(param) {
            if (!frvpToolState.active || !param.time) return;

            if (!frvpToolState.firstAnchor) {
                // Set first anchor
                frvpToolState.firstAnchor = param.time;
                addFRVPAnchorMarker(param.time, 'start');
                updateFRVPToolStatus('Click on chart to set end point...');
            } else {
                // Set second anchor
                frvpToolState.secondAnchor = param.time;
                addFRVPAnchorMarker(param.time, 'end');
                updateFRVPToolStatus('Calculating FRVP...');

                // Ensure correct order (start < end)
                const startTime = Math.min(frvpToolState.firstAnchor, frvpToolState.secondAnchor);
                const endTime = Math.max(frvpToolState.firstAnchor, frvpToolState.secondAnchor);

                // Check if editing existing overlay
                if (frvpToolState.editingOverlayId) {
                    const overlayId = frvpToolState.editingOverlayId;
                    frvpToolState.editingOverlayId = null;

                    // Remove old overlay
                    removeFRVPOverlay(overlayId, false);

                    // Create new overlay with updated range
                    renderFRVPOverlay(startTime, endTime);
                } else {
                    // Calculate and render new FRVP overlay
                    renderFRVPOverlay(startTime, endTime);
                }

                // Reset tool
                deactivateFRVPTool();
            }
        }

        // --- FRVP Draggable Anchors ---

        function createDraggableAnchor(time, type, overlayId) {
            const chartContainer = document.getElementById('tvchart');
            const anchor = document.createElement('div');
            anchor.className = 'frvp-anchor'; // style in css or inline
            anchor.id = `anchor-${overlayId}-${type}`;
            anchor.dataset.overlayId = overlayId;
            anchor.dataset.type = type;
            anchor.dataset.time = time;

            // Inline Styles for functionality and basic look
            Object.assign(anchor.style, {
                position: 'absolute',
                zIndex: '50',
                cursor: 'ew-resize',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                width: '20px',
                height: '20px',
                transform: 'translate(-50%, -50%)',
                touchAction: 'none' // prevent scrolling on touch
            });

            // Visual Dot
            const dot = document.createElement('div');
            Object.assign(dot.style, {
                width: '14px',
                height: '14px',
                borderRadius: '50%',
                background: type === 'start' ? '#10b981' : '#ef4444',
                border: '2px solid white',
                boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
            });
            anchor.appendChild(dot);

            // Label
            const label = document.createElement('div');
            label.innerText = type === 'start' ? 'START' : 'END';
            Object.assign(label.style, {
                position: 'absolute',
                top: '-24px',
                fontSize: '11px',
                fontWeight: '700',
                color: 'white',
                background: 'rgba(0,0,0,0.75)',
                padding: '2px 6px',
                borderRadius: '4px',
                whiteSpace: 'nowrap',
                pointerEvents: 'none'
            });
            anchor.appendChild(label);

            chartContainer.appendChild(anchor);
            frvpAnchors.push(anchor);

            // Initial Position
            updateAnchorPosition(anchor);

            // --- Drag Interaction ---
            let isDragging = false;

            anchor.addEventListener('mousedown', (e) => {
                isDragging = true;
                anchor.style.cursor = 'grabbing';
                document.body.style.cursor = 'grabbing';

                // Disable chart scrolling while dragging anchor
                chart.applyOptions({ handleScroll: false, handleScale: false });

                e.stopPropagation();
                e.preventDefault();
            });

            // Use window listeners for smooth dragging outside element
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const rect = chartContainer.getBoundingClientRect();
                const x = e.clientX - rect.left;

                // Convert coordinate to time
                const timeScale = chart.timeScale();
                const time = timeScale.coordinateToTime(x);

                if (time) {
                    anchor.dataset.time = time;
                    updateAnchorPosition(anchor);
                }
            });

            window.addEventListener('mouseup', (e) => {
                if (!isDragging) return;
                isDragging = false;

                anchor.style.cursor = 'ew-resize';
                document.body.style.cursor = 'default';
                chart.applyOptions({ handleScroll: true, handleScale: true });

                // Trigger Update
                const newTime = Number(anchor.dataset.time);
                const otherType = type === 'start' ? 'end' : 'start';
                const otherAnchor = document.getElementById(`anchor-${overlayId}-${otherType}`);

                if (otherAnchor) {
                    const otherTime = Number(otherAnchor.dataset.time);
                    const newStart = Math.min(newTime, otherTime);
                    const newEnd = Math.max(newTime, otherTime);

                    updateFRVPOverlayRange(overlayId, newStart, newEnd);
                }
            });

            return anchor;
        }

        function updateAnchorPosition(anchor) {
            if (!chart) return;
            const time = Number(anchor.dataset.time);
            const timeScale = chart.timeScale();

            // Use logical index to check visibility better if needed, 
            // but timeToCoordinate returns null if widely off-screen sometimes.
            // Using logicalToCoordinate is safer if we find the index.
            let x = timeScale.timeToCoordinate(time);

            // Fallback to logical search if null (offscreen or gap)
            if (x === null && klinedata && klinedata.length > 0) {
                const idx = klinedata.findIndex(k => k.time === time);
                if (idx !== -1) {
                    x = timeScale.logicalToCoordinate(idx);
                }
            }

            if (x === null) {
                anchor.style.display = 'none';
            } else {
                anchor.style.display = 'flex';
                anchor.style.left = x + 'px';
                anchor.style.top = '80%'; // Fixed height for anchors
            }
        }

        // Global updater for panning/zooming
        function updateAllAnchors() {
            frvpAnchors.forEach(updateAnchorPosition);
        }

        async function updateFRVPOverlayRange(overlayId, startTime, endTime) {
            // Find Overlay
            const overlay = frvpToolState.instances.find(o => o.id === overlayId);
            if (!overlay) return;

            console.log(`üîÑ Updating FRVP ${overlayId} range:`, startTime, endTime);

            // 1. Recalculate Profile
            const rangeCandles = klinedata.filter(c => c.time >= startTime && c.time <= endTime);
            const symbol = document.getElementById('symbol').value;
            // Format dates
            const startDate = new Date(startTime * 1000);
            const endDate = new Date(endTime * 1000);
            const rangeFrom = startDate.toISOString().split('T')[0];
            const rangeTo = endDate.toISOString().split('T')[0];

            try {
                const profileData = await calculateFRVP(rangeCandles, symbol, rangeFrom, rangeTo, overlay.config);

                // 2. Update Overlay Data
                overlay.startTime = startTime;
                overlay.endTime = endTime;
                overlay.profileData = profileData;

                // 3. Update Visuals
                // Remove old lines
                overlay.lineSeries.forEach(ls => chart.removeSeries(ls.series));
                overlay.lineSeries = [];

                // Re-add lines (POC, VAH, VAL) - Refactored for reuse
                const addLine = (key, data, name) => {
                    if (profileData.config.indicators?.[key]?.enabled) {
                        const s = chart.addLineSeries({
                            color: profileData.config.indicators[key].color,
                            lineWidth: profileData.config.indicators[key].width,
                            lineStyle: getLineStyleConstant(profileData.config.indicators[key].lineStyle),
                            title: `${name} (${overlayId.slice(-4)})`,
                            lastValueVisible: false,
                            priceLineVisible: false
                        });
                        s.setData([
                            { time: startTime, value: data.priceLevel },
                            { time: endTime, value: data.priceLevel }
                        ]);
                        overlay.lineSeries.push({ type: name, series: s });
                    }
                };

                addLine('POC', profileData.poc, 'POC');
                addLine('VAH', profileData.vah, 'VAH');
                addLine('VAL', profileData.val, 'VAL');

                // Re-draw Histogram
                if (overlay.canvas) {
                    drawHistogram(overlay.canvas, profileData, startTime, endTime);
                }

                console.log('‚úÖ FRVP range updated successfully');

            } catch (err) {
                console.error('Failed to update FRVP range:', err);
            }
        }
        // --- End Draggable Anchors ---

        // Replaced old marker function
        function addFRVPAnchorMarker(time, type) {
            // No-op for now, as we use DOM anchors
        }

        async function renderFRVPOverlay(startTime, endTime, overlayId = null, existingConfig = null) {
            try {
                // Filter candles between anchors
                const rangeCandles = klinedata.filter(c =>
                    c.time >= startTime && c.time <= endTime
                );

                if (rangeCandles.length === 0) {
                    console.warn('‚ö†Ô∏è No data in selected FRVP range');
                    // We still create the object to "persist" it, but maybe without visuals?
                    // Or return null? If we return null, it's lost. 
                    // Better to create it but it will be invisible.
                }

                const rangeFrom = new Date(startTime * 1000).toISOString().split('T')[0];
                const rangeTo = new Date(endTime * 1000).toISOString().split('T')[0];
                const symbol = document.getElementById('symbol').value;

                // Use existing ID or generate new
                if (!overlayId) {
                    overlayId = `frvp_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                }

                // Check default config
                const config = existingConfig || {
                    rowSize: 100,
                    volume: 'Up/Down',
                    valueAreaVolume: 70,
                    volumeProfile: {
                        enabled: true,
                        width: 30,
                        placement: 'Left',
                        color: 'rgba(0, 150, 255, 0.3)'
                    },
                    colors: {
                        upVolume: { color: 'rgba(0, 150, 136, 0.5)' },
                        downVolume: { color: 'rgba(255, 82, 82, 0.5)' },
                        valueArea: { color: 'rgba(0, 0, 255, 0.3)' }
                    },
                    indicators: {
                        POC: { enabled: true, color: '#FFD700', width: 2, lineStyle: 'Solid' },
                        VAH: { enabled: true, color: '#FFA500', width: 1, lineStyle: 'Dashed' },
                        VAL: { enabled: true, color: '#FFA500', width: 1, lineStyle: 'Dashed' }
                    }
                };

                updateFRVPToolStatus('Calculating FRVP...');
                const profileData = await calculateFRVP(rangeCandles, symbol, rangeFrom, rangeTo, config);
                updateFRVPToolStatus('FRVP Ready');

                const overlay = {
                    id: overlayId,
                    startTime: startTime,
                    endTime: endTime,
                    config: config,
                    profileData: profileData,
                    lineSeries: [],
                    canvas: null
                };

                // Add to state immediately so we can track it
                frvpToolState.instances.push(overlay);
                updateFRVPControlPanel();

                // Create range-limited line series for POC
                if (profileData.config.indicators?.POC?.enabled) {
                    const pocSeries = chart.addLineSeries({
                        color: profileData.config.indicators.POC.color,
                        lineWidth: profileData.config.indicators.POC.width,
                        lineStyle: getLineStyleConstant(profileData.config.indicators.POC.lineStyle),
                        title: `POC (${overlayId.slice(-4)})`,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });

                    pocSeries.setData([
                        { time: startTime, value: profileData.poc.priceLevel },
                        { time: endTime, value: profileData.poc.priceLevel }
                    ]);

                    overlay.lineSeries.push({ type: 'POC', series: pocSeries });
                }

                // Create range-limited line series for VAH
                if (profileData.config.indicators?.VAH?.enabled) {
                    const vahSeries = chart.addLineSeries({
                        color: profileData.config.indicators.VAH.color,
                        lineWidth: profileData.config.indicators.VAH.width,
                        lineStyle: getLineStyleConstant(profileData.config.indicators.VAH.lineStyle),
                        title: `VAH (${overlayId.slice(-4)})`,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });

                    vahSeries.setData([
                        { time: startTime, value: profileData.vah.priceLevel },
                        { time: endTime, value: profileData.vah.priceLevel }
                    ]);

                    overlay.lineSeries.push({ type: 'VAH', series: vahSeries });
                }

                // Create range-limited line series for VAL
                if (profileData.config.indicators?.VAL?.enabled) {
                    const valSeries = chart.addLineSeries({
                        color: profileData.config.indicators.VAL.color,
                        lineWidth: profileData.config.indicators.VAL.width,
                        lineStyle: getLineStyleConstant(profileData.config.indicators.VAL.lineStyle),
                        title: `VAL (${overlayId.slice(-4)})`,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });

                    valSeries.setData([
                        { time: startTime, value: profileData.val.priceLevel },
                        { time: endTime, value: profileData.val.priceLevel }
                    ]);

                    overlay.lineSeries.push({ type: 'VAL', series: valSeries });
                }

                // Create canvas overlay for histogram
                if (profileData.config.volumeProfile?.enabled) {
                    overlay.canvas = createHistogramCanvas(overlayId, profileData, startTime, endTime);
                }

                // Create Draggable Anchors
                createDraggableAnchor(startTime, 'start', overlayId);
                createDraggableAnchor(endTime, 'end', overlayId);

                // Check Global Listener
                if (chart && !window.frvpScrollListenerAttached) {
                    // We handle this in renderChart/setupFRVPListeners now, but logic here is ok safety check
                    // setupFRVPListeners(); 
                }

                return overlay;

            } catch (error) {
                console.error('Error rendering FRVP overlay:', error);
                updateFRVPToolStatus('Error: ' + error.message);
                return null;
            }
        }

        function createHistogramCanvas(overlayId, profileData, startTime, endTime) {
            const chartContainer = document.getElementById('tvchart');

            // Create canvas element
            const canvas = document.createElement('canvas');
            canvas.id = `frvp-histogram-${overlayId}`;
            canvas.className = 'frvp-histogram-canvas';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '10';

            // Make chart container position relative if not already
            if (getComputedStyle(chartContainer).position === 'static') {
                chartContainer.style.position = 'relative';
            }

            // Set canvas size to match chart
            const chartRect = chartContainer.getBoundingClientRect();
            canvas.width = chartRect.width;
            canvas.height = chartRect.height;
            canvas.style.width = chartRect.width + 'px';
            canvas.style.height = chartRect.height + 'px';

            chartContainer.appendChild(canvas);

            console.log('üìä Canvas created:', {
                id: canvas.id,
                width: canvas.width,
                height: canvas.height,
                zIndex: canvas.style.zIndex
            });

            // Draw histogram
            drawHistogram(canvas, profileData, startTime, endTime);

            // Redraw on chart resize/zoom
            const resizeObserver = new ResizeObserver(() => {
                const newRect = chartContainer.getBoundingClientRect();
                canvas.width = newRect.width;
                canvas.height = newRect.height;
                canvas.style.width = newRect.width + 'px';
                canvas.style.height = newRect.height + 'px';
                drawHistogram(canvas, profileData, startTime, endTime);
            });
            resizeObserver.observe(chartContainer);

            // Store observer for cleanup
            canvas._resizeObserver = resizeObserver;

            return canvas;
        }

        function drawHistogram(canvas, profileData, startTime, endTime) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const { rows, valueAreaRows } = profileData;
            const config = profileData.config;

            if (!config.volumeProfile?.enabled) {
                console.log('‚ö†Ô∏è Histogram disabled in config');
                return;
            }

            // Get chart dimensions and visible range
            const timeScale = chart.timeScale();

            try {
                // Get time coordinates using logical indices to handle off-screen rendering
                // helper to find index
                const findIndex = (t) => {
                    // Assuming klinedata is sorted
                    // precise match or closest? FRVP anchors are exact times from clicks
                    let idx = klinedata.findIndex(k => k.time === t);
                    return idx;
                };

                const startIdx = findIndex(startTime);
                const endIdx = findIndex(endTime);

                if (startIdx === -1 || endIdx === -1) {
                    console.warn('‚ö†Ô∏è Anchors not found in data');
                    return;
                }

                const startX = timeScale.logicalToCoordinate(startIdx);
                const endX = timeScale.logicalToCoordinate(endIdx);

                console.log('üìä Drawing histogram:', {
                    startX,
                    endX,
                    startIdx,
                    endIdx,
                    rows: rows.length
                });

                // If both are null (should rarely happen with logicalToCoordinate unless series is empty)
                if (startX === null || endX === null) {
                    return;
                }

                // If coordinates are way off screen, we still draw, the canvas clips it.
                // startX/endX can be negative or > canvas.width


                const rangeWidth = Math.abs(endX - startX);
                const histogramWidth = (rangeWidth * config.volumeProfile.width) / 100;
                const placement = config.volumeProfile.placement || 'Left';
                const histogramX = placement === 'Left' ? Math.min(startX, endX) : Math.max(startX, endX) - histogramWidth;

                console.log('üìä Histogram dimensions:', {
                    rangeWidth,
                    histogramWidth,
                    histogramX,
                    placement
                });

                // Find max volume for scaling
                const maxVolume = Math.max(...rows.map(r => r.totalVolume));
                if (maxVolume === 0) {
                    console.warn('‚ö†Ô∏è Max volume is zero');
                    return;
                }

                let barsDrawn = 0;

                // Draw each row
                rows.forEach(row => {
                    if (row.totalVolume === 0) return;

                    // Get Y coordinates for this price level using series API
                    const yTop = candleSeries.priceToCoordinate(row.priceHigh);
                    const yBottom = candleSeries.priceToCoordinate(row.priceLow);

                    if (yTop === null || yBottom === null) return;

                    const barHeight = Math.abs(yBottom - yTop);
                    const volumeRatio = row.totalVolume / maxVolume;
                    const barWidth = volumeRatio * histogramWidth;

                    // Determine colors based on value area membership
                    const isInVA = valueAreaRows.has(row.index);
                    const upColor = isInVA ? config.colors.valueAreaUp : config.colors.upVolume;
                    const downColor = isInVA ? config.colors.valueAreaDown : config.colors.downVolume;

                    // Calculate up/down volume widths
                    const upRatio = row.totalVolume > 0 ? row.upVolume / row.totalVolume : 0;
                    const downRatio = row.totalVolume > 0 ? row.downVolume / row.totalVolume : 0;

                    // Draw up volume bar
                    if (row.upVolume > 0) {
                        ctx.fillStyle = hexToRgba(upColor.color, upColor.opacity);
                        ctx.fillRect(
                            histogramX,
                            Math.min(yTop, yBottom),
                            barWidth * upRatio,
                            barHeight
                        );
                        barsDrawn++;
                    }

                    // Draw down volume bar
                    if (row.downVolume > 0) {
                        ctx.fillStyle = hexToRgba(downColor.color, downColor.opacity);
                        ctx.fillRect(
                            histogramX + (barWidth * upRatio),
                            Math.min(yTop, yBottom),
                            barWidth * downRatio,
                            barHeight
                        );
                        barsDrawn++;
                    }
                });

                console.log(`‚úÖ Histogram drawn: ${barsDrawn} bars`);

            } catch (e) {
                console.error('‚ùå Failed to draw histogram:', e);
            }
        }

        function hexToRgba(hex, opacity) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const alpha = opacity / 100;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function updateFRVPControlPanel() {
            const panel = document.getElementById('frvpControlPanel');
            if (!panel) return;

            // Clear existing controls
            panel.innerHTML = '';

            // Add control for each overlay
            frvpToolState.instances.forEach((overlay, index) => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'frvp-overlay-control';
                controlDiv.innerHTML = `
                    <span class="frvp-overlay-label">FRVP #${index + 1}</span>
                    <button class="frvp-control-btn edit-btn" onclick="editFRVPRange('${overlay.id}')" title="Edit Range">
                        ‚úèÔ∏è Edit
                    </button>
                    <button class="frvp-control-btn settings-btn" onclick="openFRVPSettings('${overlay.id}')" title="Settings">
                        ‚öôÔ∏è Settings
                    </button>
                    <button class="frvp-control-btn delete-btn" onclick="removeFRVPOverlay('${overlay.id}')" title="Delete">
                        üóëÔ∏è Delete
                    </button>
                `;
                panel.appendChild(controlDiv);
            });
        }

        function openFRVPSettings(overlayId) {
            const overlay = frvpToolState.instances.find(o => o.id === overlayId);
            if (!overlay) return;

            // Create settings modal
            const modal = document.createElement('div');
            modal.className = 'frvp-settings-modal';
            modal.innerHTML = `
                <div class="frvp-settings-content">
                    <div class="frvp-settings-header">
                        <h3>FRVP Settings (${overlayId.slice(-4)})</h3>
                        <button onclick="closeFRVPSettings('${overlayId}')" class="close-btn">√ó</button>
                    </div>
                    <div class="frvp-settings-body">
                        <div class="settings-group">
                            <label>Row Size</label>
                            <input type="number" id="frvp-rowSize-${overlayId}" value="${overlay.config.rowSize}" min="10" max="1000">
                        </div>
                        <div class="settings-group">
                            <label>Volume</label>
                            <select id="frvp-volume-${overlayId}">
                                <option value="Total" ${overlay.config.volume === 'Total' ? 'selected' : ''}>Total</option>
                                <option value="Up/Down" ${overlay.config.volume === 'Up/Down' ? 'selected' : ''}>Up/Down</option>
                                <option value="Delta" ${overlay.config.volume === 'Delta' ? 'selected' : ''}>Delta</option>
                            </select>
                        </div>
                        <div class="settings-group">
                            <label>Value Area %</label>
                            <input type="number" id="frvp-valueArea-${overlayId}" value="${overlay.config.valueAreaVolume}" min="0" max="100">
                        </div>
                        <div class="settings-group">
                            <label>Width %</label>
                            <input type="number" id="frvp-width-${overlayId}" value="${overlay.config.volumeProfile.width}" min="0" max="100">
                        </div>
                        <div class="settings-group">
                            <label>Up Volume Color</label>
                            <input type="color" id="frvp-upColor-${overlayId}" value="${overlay.config.colors.upVolume.color}">
                        </div>
                        <div class="settings-group">
                            <label>Down Volume Color</label>
                            <input type="color" id="frvp-downColor-${overlayId}" value="${overlay.config.colors.downVolume.color}">
                        </div>
                        <div class="settings-group">
                            <label class="checkbox-wrap">
                                <input type="checkbox" id="frvp-poc-${overlayId}" ${overlay.config.indicators.POC.enabled ? 'checked' : ''}> POC
                            </label>
                            <label class="checkbox-wrap">
                                <input type="checkbox" id="frvp-vah-${overlayId}" ${overlay.config.indicators.VAH.enabled ? 'checked' : ''}> VAH
                            </label>
                            <label class="checkbox-wrap">
                                <input type="checkbox" id="frvp-val-${overlayId}" ${overlay.config.indicators.VAL.enabled ? 'checked' : ''}> VAL
                            </label>
                        </div>
                        
                        <hr style="margin: 1rem 0; border: none; border-top: 1px solid rgba(148, 163, 184, 0.2);">
                        <h4 style="margin-bottom: 1rem; color: var(--text-secondary); font-size: 0.875rem;">Line Styling</h4>
                        
                        <div class="settings-group">
                            <label>POC Color</label>
                            <input type="color" id="frvp-pocColor-${overlayId}" value="${overlay.config.indicators.POC.color}">
                            <label style="margin-left: 1rem;">Width</label>
                            <input type="number" id="frvp-pocWidth-${overlayId}" value="${overlay.config.indicators.POC.width}" min="1" max="10" style="width: 60px;">
                            <label style="margin-left: 1rem;">Style</label>
                            <select id="frvp-pocStyle-${overlayId}" style="width: 100px;">
                                <option value="solid" ${overlay.config.indicators.POC.lineStyle === 'solid' ? 'selected' : ''}>Solid</option>
                                <option value="dotted" ${overlay.config.indicators.POC.lineStyle === 'dotted' ? 'selected' : ''}>Dotted</option>
                                <option value="dashed" ${overlay.config.indicators.POC.lineStyle === 'dashed' ? 'selected' : ''}>Dashed</option>
                            </select>
                        </div>
                        
                        <div class="settings-group">
                            <label>VAH Color</label>
                            <input type="color" id="frvp-vahColor-${overlayId}" value="${overlay.config.indicators.VAH.color}">
                            <label style="margin-left: 1rem;">Width</label>
                            <input type="number" id="frvp-vahWidth-${overlayId}" value="${overlay.config.indicators.VAH.width}" min="1" max="10" style="width: 60px;">
                            <label style="margin-left: 1rem;">Style</label>
                            <select id="frvp-vahStyle-${overlayId}" style="width: 100px;">
                                <option value="solid" ${overlay.config.indicators.VAH.lineStyle === 'solid' ? 'selected' : ''}>Solid</option>
                                <option value="dotted" ${overlay.config.indicators.VAH.lineStyle === 'dotted' ? 'selected' : ''}>Dotted</option>
                                <option value="dashed" ${overlay.config.indicators.VAH.lineStyle === 'dashed' ? 'selected' : ''}>Dashed</option>
                            </select>
                        </div>
                        
                        <div class="settings-group">
                            <label>VAL Color</label>
                            <input type="color" id="frvp-valColor-${overlayId}" value="${overlay.config.indicators.VAL.color}">
                            <label style="margin-left: 1rem;">Width</label>
                            <input type="number" id="frvp-valWidth-${overlayId}" value="${overlay.config.indicators.VAL.width}" min="1" max="10" style="width: 60px;">
                            <label style="margin-left: 1rem;">Style</label>
                            <select id="frvp-valStyle-${overlayId}" style="width: 100px;">
                                <option value="solid" ${overlay.config.indicators.VAL.lineStyle === 'solid' ? 'selected' : ''}>Solid</option>
                                <option value="dotted" ${overlay.config.indicators.VAL.lineStyle === 'dotted' ? 'selected' : ''}>Dotted</option>
                                <option value="dashed" ${overlay.config.indicators.VAL.lineStyle === 'dashed' ? 'selected' : ''}>Dashed</option>
                            </select>
                        </div>
                    </div>
                    <div class="frvp-settings-footer">
                        <button onclick="removeFRVPOverlay('${overlayId}')" class="btn-danger">Remove</button>
                        <button onclick="applyFRVPSettings('${overlayId}')" class="btn-primary">Apply</button>
                    </div>
                </div>
            `;
            modal.id = `frvp-modal-${overlayId}`;
            document.body.appendChild(modal);
        }

        function closeFRVPSettings(overlayId) {
            const modal = document.getElementById(`frvp-modal-${overlayId}`);
            if (modal) modal.remove();
        }

        function editFRVPRange(overlayId) {
            const overlay = frvpToolState.instances.find(o => o.id === overlayId);
            if (!overlay) return;

            // Store overlay ID for editing
            frvpToolState.editingOverlayId = overlayId;

            // Activate tool
            activateFRVPTool();

            // Update status
            updateFRVPToolStatus('Editing FRVP range - Click new start point...');
        }

        function editFRVPRange(overlayId) {
            const overlay = frvpToolState.instances.find(o => o.id === overlayId);
            if (!overlay) return;

            // Store overlay ID for editing
            frvpToolState.editingOverlayId = overlayId;

            // Activate tool
            activateFRVPTool();

            // Update status
            updateFRVPToolStatus('Editing FRVP range - Click new start point...');
        }

        async function applyFRVPSettings(overlayId) {
            const overlay = frvpToolState.instances.find(o => o.id === overlayId);
            if (!overlay) return;

            // Get new settings from inputs
            const newConfig = {
                ...overlay.config,
                rowSize: parseInt(document.getElementById(`frvp-rowSize-${overlayId}`).value),
                volume: document.getElementById(`frvp-volume-${overlayId}`).value,
                valueAreaVolume: parseInt(document.getElementById(`frvp-valueArea-${overlayId}`).value),
                volumeProfile: {
                    ...overlay.config.volumeProfile,
                    width: parseInt(document.getElementById(`frvp-width-${overlayId}`).value)
                },
                colors: {
                    ...overlay.config.colors,
                    upVolume: {
                        ...overlay.config.colors.upVolume,
                        color: document.getElementById(`frvp-upColor-${overlayId}`).value
                    },
                    downVolume: {
                        ...overlay.config.colors.downVolume,
                        color: document.getElementById(`frvp-downColor-${overlayId}`).value
                    }
                },
                indicators: {
                    ...overlay.config.indicators,
                    POC: {
                        ...overlay.config.indicators.POC,
                        enabled: document.getElementById(`frvp-poc-${overlayId}`).checked,
                        color: document.getElementById(`frvp-pocColor-${overlayId}`).value,
                        width: parseInt(document.getElementById(`frvp-pocWidth-${overlayId}`).value),
                        lineStyle: document.getElementById(`frvp-pocStyle-${overlayId}`).value
                    },
                    VAH: {
                        ...overlay.config.indicators.VAH,
                        enabled: document.getElementById(`frvp-vah-${overlayId}`).checked,
                        color: document.getElementById(`frvp-vahColor-${overlayId}`).value,
                        width: parseInt(document.getElementById(`frvp-vahWidth-${overlayId}`).value),
                        lineStyle: document.getElementById(`frvp-vahStyle-${overlayId}`).value
                    },
                    VAL: {
                        ...overlay.config.indicators.VAL,
                        enabled: document.getElementById(`frvp-val-${overlayId}`).checked,
                        color: document.getElementById(`frvp-valColor-${overlayId}`).value,
                        width: parseInt(document.getElementById(`frvp-valWidth-${overlayId}`).value),
                        lineStyle: document.getElementById(`frvp-valStyle-${overlayId}`).value
                    }
                }
            };

            // Remove only visual elements (keep overlay in instances)
            overlay.lineSeries.forEach(ls => {
                try {
                    chart.removeSeries(ls.series);
                } catch (e) {
                    console.warn('Failed to remove line series:', e);
                }
            });

            if (overlay.canvas) {
                try {
                    if (overlay.canvas._resizeObserver) {
                        overlay.canvas._resizeObserver.disconnect();
                    }
                    overlay.canvas.remove();
                } catch (e) {
                    console.warn('Failed to remove canvas:', e);
                }
            }

            // Recalculate with new settings
            const rangeFrom = new Date(overlay.startTime * 1000).toISOString().split('T')[0];
            const rangeTo = new Date(overlay.endTime * 1000).toISOString().split('T')[0];
            const symbol = document.getElementById('symbol').value;
            const rangeCandles = klinedata.filter(c => c.time >= overlay.startTime && c.time <= overlay.endTime);

            const profileData = await calculateFRVP(rangeCandles, symbol, rangeFrom, rangeTo, newConfig);

            // Update overlay in place
            overlay.profileData = profileData;
            overlay.config = newConfig;
            overlay.lineSeries = [];
            overlay.canvas = null;

            // Recreate visuals using same overlay object
            const newLineSeries = [];

            // Recreate POC line
            if (profileData.config.indicators?.POC?.enabled) {
                const pocSeries = chart.addLineSeries({
                    color: profileData.config.indicators.POC.color,
                    lineWidth: profileData.config.indicators.POC.width,
                    lineStyle: getLineStyleConstant(profileData.config.indicators.POC.lineStyle),
                    title: `POC (${overlayId.slice(-4)})`,
                    lastValueVisible: false,
                    priceLineVisible: false,
                });
                pocSeries.setData([
                    { time: overlay.startTime, value: profileData.poc.priceLevel },
                    { time: overlay.endTime, value: profileData.poc.priceLevel }
                ]);
                newLineSeries.push({ type: 'POC', series: pocSeries });
            }

            // Recreate VAH line
            if (profileData.config.indicators?.VAH?.enabled) {
                const vahSeries = chart.addLineSeries({
                    color: profileData.config.indicators.VAH.color,
                    lineWidth: profileData.config.indicators.VAH.width,
                    lineStyle: getLineStyleConstant(profileData.config.indicators.VAH.lineStyle),
                    title: `VAH (${overlayId.slice(-4)})`,
                    lastValueVisible: false,
                    priceLineVisible: false,
                });
                vahSeries.setData([
                    { time: overlay.startTime, value: profileData.vah.priceLevel },
                    { time: overlay.endTime, value: profileData.vah.priceLevel }
                ]);
                newLineSeries.push({ type: 'VAH', series: vahSeries });
            }

            // Recreate VAL line
            if (profileData.config.indicators?.VAL?.enabled) {
                const valSeries = chart.addLineSeries({
                    color: profileData.config.indicators.VAL.color,
                    lineWidth: profileData.config.indicators.VAL.width,
                    lineStyle: getLineStyleConstant(profileData.config.indicators.VAL.lineStyle),
                    title: `VAL (${overlayId.slice(-4)})`,
                    lastValueVisible: false,
                    priceLineVisible: false,
                });
                valSeries.setData([
                    { time: overlay.startTime, value: profileData.val.priceLevel },
                    { time: overlay.endTime, value: profileData.val.priceLevel }
                ]);
                newLineSeries.push({ type: 'VAL', series: valSeries });
            }

            overlay.lineSeries = newLineSeries;

            // Recreate histogram
            if (profileData.config.volumeProfile?.enabled) {
                overlay.canvas = createHistogramCanvas(overlayId, profileData, overlay.startTime, overlay.endTime);
            }

            closeFRVPSettings(overlayId);
            console.log('‚úÖ FRVP settings applied:', overlayId);
        }

        function removeFRVPOverlay(overlayId, closeModal = true) {
            const index = frvpToolState.instances.findIndex(o => o.id === overlayId);
            if (index === -1) return;

            const overlay = frvpToolState.instances[index];

            // Remove line series (changed from price lines)
            overlay.lineSeries.forEach(ls => {
                try {
                    chart.removeSeries(ls.series);
                } catch (e) {
                    console.warn('Failed to remove line series:', e);
                }
            });

            // Remove canvas overlay
            if (overlay.canvas) {
                try {
                    // Disconnect resize observer
                    if (overlay.canvas._resizeObserver) {
                        overlay.canvas._resizeObserver.disconnect();
                    }
                    // Remove canvas from DOM
                    overlay.canvas.remove();
                } catch (e) {
                    console.warn('Failed to remove canvas:', e);
                }
            }

            // Remove from instances
            frvpToolState.instances.splice(index, 1);

            // Remove markers associated with this overlay (Legacy Check)
            const existingMarkers = candleSeries.markers ? candleSeries.markers() : [];
            const filteredMarkers = existingMarkers.filter(m => m.id !== overlayId);
            candleSeries.setMarkers(filteredMarkers);

            // Remove Draggable Anchors (DOM)
            const startAnchor = document.getElementById(`anchor-${overlayId}-start`);
            const endAnchor = document.getElementById(`anchor-${overlayId}-end`);

            if (startAnchor) {
                startAnchor.remove();
                // Remove from tracking array
                const idx = frvpAnchors.indexOf(startAnchor);
                if (idx > -1) frvpAnchors.splice(idx, 1);
            }
            if (endAnchor) {
                endAnchor.remove();
                const idx = frvpAnchors.indexOf(endAnchor);
                if (idx > -1) frvpAnchors.splice(idx, 1);
            }

            // Update control panel
            updateFRVPControlPanel();

            if (closeModal) {
                closeFRVPSettings(overlayId);
            }

            console.log('üóëÔ∏è FRVP overlay removed:', overlayId);
        }

        // Redraw histograms on chart zoom/pan/scroll
        chart?.timeScale().subscribeVisibleLogicalRangeChange(() => {
            frvpToolState.instances.forEach(overlay => {
                if (overlay.canvas && overlay.profileData) {
                    drawHistogram(overlay.canvas, overlay.profileData, overlay.startTime, overlay.endTime);
                }
            });
        });

        // ALSO redraw on pan (time range change)
        chart?.timeScale().subscribeVisibleTimeRangeChange(() => {
            frvpToolState.instances.forEach(overlay => {
                if (overlay.canvas && overlay.profileData) {
                    drawHistogram(overlay.canvas, overlay.profileData, overlay.startTime, overlay.endTime);
                }
            });
        });

        window.addEventListener('load', () => {
            renderChart();
        });
    </script>
</body>

</html>